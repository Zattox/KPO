# Отчет по БДЗ-3, Тепляков Владислав Витальевич, БПИ2310

## Тестирование
1. Проверьте установку docker-compose и docker
    ```bash
   docker --version
   docker-compose --version
   ```
2. Перейдите в корневую папку проекта и пропишите для запуска проекта `docker-compose up --build`
3. Для ручного тестирования перейдите по адресу в браузере:
- API Gateway Swagger: http://localhost:8080/swagger
- Orders Service: http://localhost:5001/swagger
- Payments Service: http://localhost:5002/swagger
4. Для остановки контейнеров: `docker compose down --volumes`

## Архитектурный обзор

### Компоненты системы
1. **API Gateway** (порт 8080) - централизованная точка входа для маршрутизации запросов
2. **Orders Service** (порт 5001) - управление заказами и их статусами
3. **Payments Service** (порт 5002) - обработка платежей и управление счетами
4. **PostgreSQL** (2 экземпляра) - хранение данных для каждого сервиса 
5. **RabbitMQ** (порты 5672, 15672) - асинхронное взаимодействие между сервисами

### Ключевые характеристики
- Четкое разделение ответственности между микросервисами согласно принципу Database Per Service 
- Событийно-ориентированная архитектура с использованием Transactional Outbox Pattern
- Полная контейнеризация через Docker с orchestration через Docker Compose

## Функциональные возможности

### API Gateway

- Маршрутизация запросов между микросервисами с использованием YARP (Yet Another Reverse Proxy)
- Агрегированная документация Swagger для всех сервисов в единой точке доступа
- Проксирование API-вызовов к Orders и Payments сервисам с правильной трансформацией путей 
- Настройка CORS для корректного взаимодействия между фронтендом (по итогу не реализован) и бэкендом

### Orders Service

- Создание заказов с автоматическим запуском процесса оплаты через асинхронные сообщения 
- Просмотр списка заказов пользователя с фильтрацией по userId 
- Отслеживание статуса заказа с автоматическим обновлением на основе результатов платежей 
- Transactional Outbox Pattern для гарантированной доставки событий

### Payments Service

- Создание счета пользователя (не более одного на пользователя) с валидацией уникальности 
- Пополнение баланса с атомарными операциями для предотвращения race conditions 
- Просмотр баланса счета в реальном времени 
- Обработка платежей с семантикой exactly once для предотвращения дублирования списаний 


## Детали реализации

### Transactional Outbox Pattern
- В Orders Service: сохранение заказа и события о создании в рамках одной транзакции 
- В Payments Service: атомарная обработка платежа и создание события о результате 
- Отдельные фоновые сервисы для вычитывания и отправки событий в RabbitMQ 

### Event-Driven Architecture

- OrderCreatedEvent: уведомление о создании нового заказа для инициации платежа 
- PaymentProcessedEvent: результат обработки платежа (успех/неудача) 
- BalanceUpdatedEvent: уведомление об изменении баланса для автообновления статусов заказов 

## Взаимодействие сервисов

### Основные сценарии
1. Создание и автооплата заказа:
    - Клиент → API Gateway → Orders Service (создание заказа)
    - Orders Service → RabbitMQ (событие OrderCreated)
    - RabbitMQ → Payments Service (обработка платежа)
    - Payments Service → RabbitMQ (событие PaymentProcessed)
    - RabbitMQ → Orders Service (обновление статуса заказа)
2. Пополнение баланса с автообновлением заказов:
    - Клиент → API Gateway → Payments Service (пополнение)
    - Payments Service → RabbitMQ (событие BalanceUpdated)
    - RabbitMQ → Orders Service (проверка ожидающих заказов)

### Коммуникация
- Синхронная: REST API через HTTP для прямых операций пользователя 
- Асинхронная: RabbitMQ для межсервисного взаимодействия и событийной обработки 
- Service Discovery: внутренний DNS Docker для обращения к сервисам по именам контейнеров 